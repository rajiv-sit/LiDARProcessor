# LiDARProcessor Architecture

## 1. Overview
- The `LiDARProcessor` executable (`test/main.cpp:8`) locates a `data/testCase.pcap` capture alongside the binary, lets the caller override the path, and hands a factory-created Velodyne sensor over to `lidar::LidarEngine` so the runtime only depends on the sensor interface (`test/main.cpp:8-28`).
- `LidarEngine` configures the sensor, keeps two reusable `PointCloud` buffers, and drives `Visualizer` updates every ~33 ms while respecting a replay-speed scale, implementing the factory/strategy/double-buffer guidance described in the docs (`velodyne/src/engine/LidarEngine.cpp:10-69`).
- Visualization lives in its own subsystem (`visualization/Visualizer.cpp:1-520`), feeding shader code in `shaders/point.vs/.fs` and exposing ImGui controls to adjust camera view, color mode, clipping, transparency, and the new altitude zoning in free-orbit/classification mode (`visualization/Visualizer.cpp:1-683`, `shaders/point.fs:1-88`).

## 2. Data capture & Reader
- The build ships a compact DAT-derived definition file (`reader/include/LidarScan.hpp:1-108`) under the `VDYNE` namespace, so scans, beams, and firing metadata are defined locally instead of relying on external frameworks.
- `reader/src/VelodynePCAPReader.cpp` parses the `.pcap` stream with the custom `GetFirstLidarScan`/`GetNextLidarScan` loop, determines timestamp scaling and device type, and populates the `VDYNE::LiDARScan_t` structures that `VelodyneLidar` consumes (`reader/src/VelodynePCAPReader.cpp`). The reader exposes a C API so the sensor class can interoperate with the existing DLL/SDK bindings.

## 3. Engine & Sensor Strategy
- `VelodyneLidar` is a `BaseLidarSensor` implementation that initializes the `VDYNE` reader, tracks HDL32/VLP16 hardware metadata, filters invalid ranges, respects the configured FOV/range, and converts azimuth/range/intensity into `(x,y,z)` points stored in the engine’s active buffer (`velodyne/src/sensors/VelodyneLidar.cpp:1-168`).
- The sensor’s vertical-angle tables and per-beam timing constants ensure the simulated scan matches real HDL32/VLP16 geometry before each frame, and `LidarEngine::captureFrame` swaps buffers and timestamps to keep the visualizer and reader in sync (`velodyne/src/sensors/VelodyneLidar.cpp:28-168`, `velodyne/src/engine/LidarEngine.cpp:37-69`).
- `VelodyneFactory` currently produces HDL-32E or VLP-16 variants and can be extended to new sensor types by adding cases that return `BaseLidarSensor` implementations (`velodyne/src/sensors/LidarFactory.cpp:12-35`).

## 4. Visualization Pipeline
- `Visualizer` exposes a GLFW window with a VAO/VBO pair for vertices, an ImGui context, and callbacks for orbit, scroll, and mouse interactions. Buffers are double-buffered so the renderer can upload ground/non-ground segments separately, and the ImGui panel controls point size, camera view/distance, replay speed, color mode, alpha mode, clipping, and coloring of ground vs. non-ground points (`visualization/Visualizer.cpp:1-520`).
- Free-orbit + classification mode assigns each point to one of five altitude zones (`z < -1.5 m`, `-1.5 ≤ z < 0`, `z = 0`, `0 < z < 1.5`, `z ≥ 1.5`), uploads the zone colors via `uZoneColors`, and lets the legend display the mapping while keeping the legacy ground/non-ground palette available for other color modes (`visualization/Visualizer.cpp:18-52`, `visualization/Visualizer.cpp:127-189`, `visualization/Visualizer.cpp:300-420`, `visualization/Visualizer.cpp:633-684`, `shaders/point.fs:7-88`).

## 5. Shader & Rendering Details
- The vertex shader scales world coordinates into clip space and forwards height/intensity/classification to the fragment shader, which now checks `uUseZoneColors` before mixing ground/non-ground palettes, evaluates height/intensity gradients, and derives alpha from the selected mode (`shaders/point.vs:1-17`, `shaders/point.fs:1-88`).
- Uniforms such as `uMinHeight`, `uMaxHeight`, and `uClipValue` are updated each frame based on the data’s min/max z, and the shader can draw transparent points whose alpha reflects either user-specified values or intensity (`visualization/Visualizer.cpp:368-410`, `shaders/point.fs:34-88`).

## 6. Build & Resources
- Conan supplies only the actively linked packages (Eigen3, GLFW, GLEW, GLM, ImGui, OpenGL system targets) to keep the dependency graph lean, and `CMakeLists.txt` copies `shaders/` and `data/` into the binary directory while linking against the targets generated by the toolchain (`conanfile.py`, `CMakeLists.txt:21-64`).
- Helper scripts like `run_debug.bat` wrap Conan install + CMake configure/build + resource copy so developers can recreate the workflow described above; the run script also copies `data/testCase.pcap` so the sensor replay always hits real capture frames.

## 7. Runtime Observability
- Once built, the executable logs the sensor identity (`Velodyne HDL-32E`) and keeps the ImGui stats window updated with total, ground, non-ground, and GPU capacity numbers; the double-buffering ensures the UI draws what the `VelodyneLidar` scan provided without stalling the reader (`velodyne/src/engine/LidarEngine.cpp:37-69`, `visualization/Visualizer.cpp:115-189`).

